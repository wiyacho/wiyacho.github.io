<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Cocos Creator系列之性能优化 | 永超の博客</title><meta name="description" content="cocos creator配置自己的声明文件以d.ts为后缀名的文件，会被识别为声明文件，creator.d.ts是引擎的声明文件。我们也可以定义自己的声明文件，需要注意的是声明文件要放在assets文件外，因为assets文件里的脚本都会被引擎编译，而声明文件的作用就是写代码时提示一下，编译之后就不需要了。 转换单位 Bit:”比特”或者“位”，计算机运算的基础； Byte：意为“字节”，是计算"><meta name="keywords" content="cocos creator,性能优化"><meta name="author" content="cc"><meta name="copyright" content="cc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/posts/59257/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Cocos Creator系列之性能优化"><meta property="og:url" content="http://yoursite.com/posts/59257/"><meta property="og:site_name" content="永超の博客"><meta property="og:description" content="cocos creator配置自己的声明文件以d.ts为后缀名的文件，会被识别为声明文件，creator.d.ts是引擎的声明文件。我们也可以定义自己的声明文件，需要注意的是声明文件要放在assets文件外，因为assets文件里的脚本都会被引擎编译，而声明文件的作用就是写代码时提示一下，编译之后就不需要了。 转换单位 Bit:”比特”或者“位”，计算机运算的基础； Byte：意为“字节”，是计算"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/033.webp"><meta property="article:published_time" content="2021-05-29T17:19:49.000Z"><meta property="article:modified_time" content="2022-07-21T14:22:22.669Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="Cocos Creator系列之基础面试题" href="http://yoursite.com/posts/61574/"><link rel="next" title="TCP/IP协议" href="http://yoursite.com/posts/45897/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-07-21 22:22:22'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fab fa-xbox"></i><span> 聚宝盒</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cocos-creator%E9%85%8D%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">cocos creator配置自己的声明文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%8D%95%E4%BD%8D"><span class="toc-number">2.</span> <span class="toc-text">转换单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">一、客户端优化方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">1、加载优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 图片资源优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 图片资源的模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 图片纹理的压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Prefab%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 Prefab加载优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1-%E5%90%88%E7%90%86%E6%8B%86%E5%88%86Prefab"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">1.4.1 合理拆分Prefab</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">1.4.2 延迟加载资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3-%E9%80%89%E6%8B%A9%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">1.4.3 选择优化策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%9C%BA%E6%99%AF%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.5.</span> <span class="toc-text">1.5 场景加载优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-1-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BD%AE%E4%BD%93%E6%9E%84%E6%88%90%E5%9C%BA%E6%99%AF%EF%BC%8C%E5%88%86%E6%89%B9%E5%BC%82%E6%AD%A5%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">1.5.1 合理使用预置体构成场景，分批异步进行加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-2-%E4%BD%BF%E7%94%A8%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">1.5.2 使用加载界面优化用户体验</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E8%B5%84%E6%BA%90%E6%89%B9%E9%87%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.6.</span> <span class="toc-text">1.6 资源批量加载优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">2、渲染优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%87%AA%E5%8A%A8%E5%9B%BE%E9%9B%86%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%88%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 自动图集批处理（静态合批）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E5%90%88%E6%89%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 动态合批</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">3、内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 静态资源的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 动态资源的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 动态资源的释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81CPU%E5%8D%A0%E7%94%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">4、CPU占用及性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%9A"><span class="toc-number">3.5.</span> <span class="toc-text">写代码时值得注意的点：</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/033.webp)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">永超の博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fab fa-xbox"></i><span> 聚宝盒</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Cocos Creator系列之性能优化</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-05-30 01:19:49"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-05-30</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-07-21 22:22:22"><i class="fas fa-history fa-fw"></i> 更新于 2022-07-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a><i class="fas fa-angle-right post-meta__separator"></i><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/cocos-creator/">cocos creator</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="cocos-creator配置自己的声明文件"><a href="#cocos-creator配置自己的声明文件" class="headerlink" title="cocos creator配置自己的声明文件"></a>cocos creator配置自己的声明文件</h2><p>以d.ts为后缀名的文件，会被识别为声明文件，creator.d.ts是引擎的声明文件。我们也可以定义自己的声明文件，需要注意的是声明文件要放在assets文件外，因为assets文件里的脚本都会被引擎编译，而声明文件的作用就是写代码时提示一下，编译之后就不需要了。</p>
<h2 id="转换单位"><a href="#转换单位" class="headerlink" title="转换单位"></a>转换单位</h2><ul>
<li>Bit:”比特”或者“位”，计算机运算的基础；</li>
<li>Byte：意为“字节”，是计算机文件大小的基本计算单位；简称“B”;</li>
<li>1byte = 8 bit;</li>
<li>1B = 8 Bit;</li>
<li>1KB = 1024 B;（千字节）</li>
<li>1MB = 1024 KB;(兆字节)</li>
<li>1GB = 1024 MB;(吉字节)</li>
<li>1TB = 1024 GB;(太字节)</li>
</ul>
<h2 id="一、客户端优化方法"><a href="#一、客户端优化方法" class="headerlink" title="一、客户端优化方法"></a>一、客户端优化方法</h2><p>计划大概分为四个部分：加载优化、渲染优化、内存优化、CPU占用以及性能优化。</p>
<h3 id="1、加载优化"><a href="#1、加载优化" class="headerlink" title="1、加载优化"></a>1、加载优化</h3><h4 id="1-1-图片资源优化"><a href="#1-1-图片资源优化" class="headerlink" title="1.1 图片资源优化"></a>1.1 图片资源优化</h4><ul>
<li>1、图片资源的处理，可以利用九宫格方法拉伸的尽量减小图片大小，加载时自然速度将会加快。另一方面也会带来内存的减少以及包体的减少。</li>
<li>2、相同图片不同颜色的完全可以用编辑器来改变颜色，不需要太多张图片。</li>
<li>3、另外有一点也要格外注意，cocos creator所支持的最大图片尺寸为2048*2048，超过这个尺寸的图片在显示时会有问题，常见于一些Spine动画打包出来后没注意资源图片尺寸，导致动画显示异常。</li>
<li>4、如果是地图资源超过2048*2048，常见于一些mmo项目，这种情况下，需要对地图资源进行切分，切分成小于2048*2048的若干图片，在游戏中再拼接在一起。当然这样拼接的话在摄像机或者地图移动时可能会有白边出现，需要特殊处理，这里就不详细说了。</li>
</ul>
<h4 id="1-2-图片资源的模块化"><a href="#1-2-图片资源的模块化" class="headerlink" title="1.2 图片资源的模块化"></a>1.2 图片资源的模块化</h4><p> 将各个界面的美术资源、帧动画分类并且打包成图集也是比较好的处理方法，将资源进行模块化。这样在加载时，以及游戏运行时，会有以下几点好处：</p>
<ul>
<li>1、提升加载速度。省去了多次打开/关闭文件所带来的时间损耗</li>
<li>2、减少文件的体积。多张图片合并到一起，在包体上面会有一定的优化</li>
<li>3、减少DrawCall。对渲染的性能也有优化的作用。</li>
<li>4、可以将这个界面的资源统一释放，避免占用内存。</li>
<li>5、另外通用资源可以统一打包在一张图集中，让这些通用的常用资源常驻与内存，方便使用。避免频繁的重复释放和加载。</li>
</ul>
<h4 id="1-3-图片纹理的压缩"><a href="#1-3-图片纹理的压缩" class="headerlink" title="1.3 图片纹理的压缩"></a>1.3 图片纹理的压缩</h4><ul>
<li>与程序无关，需要压缩工具来处理。</li>
<li>图片的大小指的是图片占用的包体大小，也就是文件的大小，并不是图片在内存中的大小。</li>
<li>关于内存的大小，需要注意的是，和文件的大小没有直接的关系。只和图片的长宽尺寸，也就是像素数量有关系。</li>
<li>比如一张500k大小的1024*1024的图片，在内存中的占用大小为1024*1024*4 = 4M。</li>
<li>一个是<a target="_blank" rel="noopener" href="https://pngquant.org/">https://pngquant.org/</a>  pngquant的命令行压缩图片，可以很好的集成到打包工具中。</li>
<li>另外一个是TinyPNG，<a target="_blank" rel="noopener" href="https://tinypng.com/%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E7%9A%84%E7%BD%91%E7%AB%99">https://tinypng.com/一个在线压缩图片的网站</a></li>
</ul>
<ul>
<li><p>1.3.1 PVR压缩纹理</p>
<ul>
<li>PVR纹理格式是针对iOS设备进行了特殊优化的一种纹理格式，这种纹理格式可以直接被PowerVR显卡所加载，因此在加载速度上可以带来巨大的提升。同时在内存方面也可以带来很大的优化。如果你的项目内存占用特别多，并且图片资源没有做过优化的，可以尝试使用压缩纹理。</li>
<li>但要注意的是压缩纹理是一定会带来图片上面的画质损失的，因此要根据实际的需求选择影响不大的素材进行使用。</li>
<li>常用的PVR压缩纹理的格式分为四种：PVRCT2 RGBA、PVRCT2 RGB、PVRCT4 RGBA、PVRCT4 RGB。区别在于带不带透明通道以及每个像素占用的大小。</li>
<li>PVRCT2，每个像素占用2bit。而PVRCT4，每个像素占用4bit。</li>
</ul>
</li>
<li><p>1.3.2 ETC压缩纹理</p>
<ul>
<li>iOS使用的是PVR，而android使用的压缩纹理就是另一种了，那就是ETC。</li>
<li> 需要注意的是PVR只能在iOS上使用，而ETC的话，ETC1只能在android上使用。ETC2可以在目前的iOS上和android上同时使用，不过太低端的机子就不行了。</li>
</ul>
</li>
<li><p>1.3.3 压缩纹理</p>
<ul>
<li>Cocos Creator 可以直接在编辑器中设置纹理需要的压缩方式，然后在项目发布时自动对纹理进行压缩。针对 Web 平台，支持同时导出多种图片格式，引擎将根据不同的浏览器自动下载合适的格式</li>
<li><a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/2.1/manual/zh/asset-workflow/compress-texture.html">https://docs.cocos.com/creator/2.1/manual/zh/asset-workflow/compress-texture.html</a></li>
</ul>
</li>
</ul>
<h4 id="1-4-Prefab加载优化"><a href="#1-4-Prefab加载优化" class="headerlink" title="1.4 Prefab加载优化"></a>1.4 Prefab加载优化</h4><p> Prefab这块的加载优化主要集中在两个地方：一个是load加载耗时优化，另一个是实例化耗时优化。</p>
<p> Prefab在使用时的步骤：从文件读取数据-&gt;反序列化数据-&gt;还原prefab节点树-&gt;预处理-&gt;实例化。</p>
<p> 了解了Prefab使用时做了哪些事情，我们也才好针对性的做优化。</p>
<h5 id="1-4-1-合理拆分Prefab"><a href="#1-4-1-合理拆分Prefab" class="headerlink" title="1.4.1 合理拆分Prefab"></a>1.4.1 合理拆分Prefab</h5><p>越大的prefab文件在加载过程中的耗时是越长的，而且通常不是等比，而是以类似平方曲线这样的去增加时长的。</p>
<blockquote>
<p>例如读取一个100kb的文件，可能耗时也就10毫秒，但对于一个1M或者是2M的文件，我们在加载时就不是100毫秒，可能就是几百毫秒。</p>
</blockquote>
<p>一个Prefab不是功能模块越大越好，功能职责越单一越好，遵循这个原则，可以对Prefab做更好的拆分。</p>
<h5 id="1-4-2-延迟加载资源"><a href="#1-4-2-延迟加载资源" class="headerlink" title="1.4.2 延迟加载资源"></a>1.4.2 延迟加载资源</h5><ul>
<li>在creator的资源管理器中点击编辑好的prefab资源，在属性检查器中我们可以看到延迟加载资源的选项。勾选这个选项可以减少prefab的加载耗时，但首次显示的耗时会增加。</li>
<li>这时由于勾选后，prefab所引用的资源，像图片、音效这些，不会在load时加载，而是会在prefab第一次显示的时候再进行资源的加载。<h5 id="1-4-3-选择优化策略"><a href="#1-4-3-选择优化策略" class="headerlink" title="1.4.3 选择优化策略"></a>1.4.3 选择优化策略</h5>在prefab的属性检查器中，我们可以看到优化策略这个选项。这个也需要我们根据实际的使用情况进行选择。</li>
<li>优化多次创建性能–当我们选择“优化多次创建性能”这个选项时，Prefab加载后会进行一个预处理的操作，这个预处理其实就是动态生成一些prefab的实例化代码，并把这些代码交给jit去进行优化。这样在实例化时的耗时将会大大减少，相应的，在load时的耗时会有所增加。</li>
<li>优化单词创建性能–当我们选择“优化单次创建性能”这个选项时，prefab加载后会跳过预处理的步骤，这样在加载时的耗时会减少很多，但实例化时的耗时会增加。</li>
<li>例如一些固定UI界面，由于方便加载场景或者时进行功能划分，通常会做成prefab，这种prefab只会加载一次的，就可以选择这个选项，提升加载的性能。</li>
<li>需要注意的有一点：由于微信小游戏平台禁用了动态加载代码，类似eval这些不能使用，因此优化策略这个选项在微信小游戏平台是无效的。</li>
</ul>
<h4 id="1-5-场景加载优化"><a href="#1-5-场景加载优化" class="headerlink" title="1.5 场景加载优化"></a>1.5 场景加载优化</h4><p>场景加载的常用优化方案：</p>
<h5 id="1-5-1-合理使用预置体构成场景，分批异步进行加载"><a href="#1-5-1-合理使用预置体构成场景，分批异步进行加载" class="headerlink" title="1.5.1 合理使用预置体构成场景，分批异步进行加载"></a>1.5.1 合理使用预置体构成场景，分批异步进行加载</h5><ul>
<li>使用prefab来组成场景，这时最常用并且有效的手段。比如一些场景中的一些二级界面，没必要提前放置在场景中，可以通过动态加载的方式，等使用时再加载进来。</li>
<li>整个场景可以保留一些重要节点，比如背景图+主界面按钮。可以有效的减少用户等待的时间，同时避免一次性加载一些不必要的资源进来。<h5 id="1-5-2-使用加载界面优化用户体验"><a href="#1-5-2-使用加载界面优化用户体验" class="headerlink" title="1.5.2 使用加载界面优化用户体验"></a>1.5.2 使用加载界面优化用户体验</h5></li>
<li>   cocos creator点击场景文件会有延迟加载资源，与自动释放资源。勾选延迟加载资源可以减少用户等待的时间，但是场景中的图片会一点一点显示出来。</li>
<li>   该选项会在需要显示资源的时候，才会去加载这个资源。大部分情况下可以勾选上，减少加载时间，避免加载时加载大量暂时用不到的资源。</li>
<li>   通常对于一个复杂场景，加载需要一定耗时的，一定要通过一个加载界面去优化用户的体验，这个也是常用做法了。</li>
</ul>
<h4 id="1-6-资源批量加载优化"><a href="#1-6-资源批量加载优化" class="headerlink" title="1.6 资源批量加载优化"></a>1.6 资源批量加载优化</h4><p>在实际项目中我们经常会遇到一些需要大量生成节点或者prefab的情况，例如子弹、怪物等等。<br>在生成时，如果不进行优化，很容易造成瞬间的内存飙升，从而带来游戏感受上的卡顿。<br>通常我们可能会使用这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> cc.instantiate(<span class="built_in">this</span>.prefab);</span><br><span class="line">  node.parent = <span class="built_in">this</span>.layout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">当需要批量生成的数量不多时，不会对我们的效果有太大的影响，但当数量到一定程度，例如批量生成200个时，卡顿带给用户的体验会很糟糕。</span></span><br><span class="line"><span class="string">对于这种情况我的建议是，不要在同一帧中做大量的实例化操作，避免内存的突然飙升。</span></span><br><span class="line"><span class="string">实际的解决办法有很多，比如使用schedule，setTimeOut等等。这里给大家推荐一个比较好的方法：</span></span><br><span class="line"><span class="string">借用第三方库async。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">async</span>.eachLimit(array,  <span class="number">5</span>,  <span class="function">(<span class="params">index,cb</span>)  =&gt;</span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> cc.instantiate(<span class="built_in">this</span>.prefab);</span><br><span class="line">  node.parent = <span class="built_in">this</span>.layout;</span><br><span class="line">  <span class="built_in">setTimeout</span>(cb,  <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用的代码很简单，async的eachLimit方法可以帮助我们限制每一帧实例化的数量，同时在表现效果上面与其他方法相同，同时表现更流畅，无卡顿，代码也相对比较干净。</p>
<ul>
<li>在项目中使用async很简单。</li>
<li>在项目目录下打开命令行工具</li>
<li>执行npm init，生成package.json</li>
<li>然后执行npm install async –save</li>
<li>这样就安装好async模块了。</li>
<li>接下来在项目中通过require，即可使用async库-&gt;var async = require(“async”);</li>
</ul>
<h3 id="2、渲染优化"><a href="#2、渲染优化" class="headerlink" title="2、渲染优化"></a>2、渲染优化</h3><p>渲染方面优化主要集中在如何降低draw call上，draw call越多，渲染的压力也就越大，对应的帧率可能就会下降，正常情况下如果draw call超过100就有可能带来卡顿，所以要注意这方面的优化。</p>
<h4 id="2-1-自动图集批处理（静态合批）"><a href="#2-1-自动图集批处理（静态合批）" class="headerlink" title="2.1 自动图集批处理（静态合批）"></a>2.1 自动图集批处理（静态合批）</h4><ul>
<li>draw call是openGL的描绘次数</li>
<li>一个简单的openGL的绘图次序是：设置颜色→绘图方式→顶点座标→绘制→结束。</li>
<li>每帧都会重复以上的步骤。这就是一次draw call。</li>
<li>通常每一张图片都是一个纹理，一次draw call。</li>
<li>自动图集批处理所做的事情就是将两张图片放在一张纹理里面进行绘制，这样的话每帧就只有1个draw call</li>
<li>目前creator的自动图集批处理机制为，根据节点renderCmd的顺序，将相邻顺序的所需纹理放入到同一个批次进行处理。实际表现的话大致可以理解为节点树中相邻的节点会进入同一批次。</li>
<li>例如下面这样，场景中只有一个单色精灵时，它的draw call就为1。（这里解释一下为什么左下角显示为2，这是因为左下角的信息显示也需要一次draw call，本文后面所说的draw call都是去掉这个fps显示draw call的数量）</li>
<li>使用自动图集批处理有几个限制：</li>
<li>1、单图尺寸小于512*512并且大于88。</li>
<li>2、渲染buffer必须为MeshBuffer类型的资源才能批处理。</li>
<li>3、对节点部分特殊的操作不能进入批处理。</li>
<li>第1点比较好理解，第2点的话需要各位自己去看引擎关于各个renderComponent的源码了。</li>
<li>像bmfont label和sprite都是MeshBuffer，所以它们可以进入到批处理中。而像ScaleSprite，Spine这些所使用的为QuadBuffer，因此没办法进行批处理。</li>
<li>—把图片跟文字节点分开排列，文字挨着文字节点，图片挨着图片节点。</li>
<li>利用RenderTexture减少Draw Call</li>
<li>通过官方文档我们知道，利用Camera和RenderTexture可以完成截图功能<h4 id="2-2-动态合批"><a href="#2-2-动态合批" class="headerlink" title="2.2 动态合批"></a>2.2 动态合批</h4></li>
</ul>
<p>需要能够合批的多个物体使用同一种材质球</p>
<p>在绘制的时候，这些物体通过cpu计算出它们 每个顶点 * 世界矩阵 得到世界坐标（新的顶点）。通过同一种变换参数，在世界矩阵，单位矩阵下，cpu把新的顶点 + 单位矩阵 + 材等一起交给GPU去绘制。</p>
<p>优点：</p>
<ol>
<li>合批能提升渲染性能</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用cpu 实时的计算每个顶点的世界坐标–&gt;加大cpu开销</li>
</ol>
<p>做一个权衡：动态合批的每个物体它的顶点数目不要太多，太多就不适合动态合批。当cpu计算带来的开销 大于合批之后的开销，就不合适了。</p>
<h3 id="3、内存优化"><a href="#3、内存优化" class="headerlink" title="3、内存优化"></a>3、内存优化</h3><h4 id="3-1-静态资源的内存管理"><a href="#3-1-静态资源的内存管理" class="headerlink" title="3.1 静态资源的内存管理"></a>3.1 静态资源的内存管理</h4><ul>
<li>静态资源指的是场景中直接或间接引用到的所有资源（脚本动态加载的资源不算在内）</li>
<li>在场景资源的属性编辑器中可以勾选“自动释放资源”选项，从而在切换场景时，会自动将旧场景使用的静态资源释放掉，从而节省内存的占用<h4 id="3-2-动态资源的内存管理"><a href="#3-2-动态资源的内存管理" class="headerlink" title="3.2 动态资源的内存管理"></a>3.2 动态资源的内存管理</h4></li>
<li>动态资源统一使用cc.loader进行资源的加载以及管理。2.4以后用cc.assetManager进行访问。</li>
<li>要注意的一点是，CocosCreator中通过cc.loader去加载资源的所有方法，都是异步的</li>
<li>所以需要在回调中，确认加载完成后才能使用资源。<h4 id="3-3-动态资源的释放"><a href="#3-3-动态资源的释放" class="headerlink" title="3.3 动态资源的释放"></a>3.3 动态资源的释放</h4></li>
<li>3.3.1 自动释放资源<ul>
<li>当场景切换时，由于资源已经释放，脚本中如果保留了引用，此时该引用将会变为非法引用。可以使用setAutoRelease和setAutoReleaseRecursively来保留这些资源。</li>
<li>setAutoReleaseRecursively指定资源及资源递归引用到的所有资源</li>
<li>默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。 而使用 cc.loader.loadRes 或 cc.loader.loadResDir 动态加载的资源，则不受场景设置的影响，默认不自动释放。</li>
<li>使用这个 API 可以在单个资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。</li>
</ul>
</li>
<li>3.3.2 手动释放资源<ul>
<li> <a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/manual/zh/asset-manager/release-manager.html">https://docs.cocos.com/creator/manual/zh/asset-manager/release-manager.html</a></li>
<li> cc.loader提供了以下的api，都可以去释放通过cc.loader加载进来的资源内存。2.4以后 Asset Manager 中提供了资源释放模块，用于管理资源的释放。</li>
<li> 不推荐使用cc.loader.releaseAll</li>
<li> 因为cc.loader.releaseAll会将所有通过cc.loader加载进来的动态资源全部释放掉，而在我们正常的项目开发过程中，基本上很少有场景没有使用到动态资源的情况，所以这种释放通常会带来程序的崩溃，因此使用上不推荐，最好不要使用。</li>
<li> cc.loader.release(this.prefab);</li>
<li> 例如在release一个prefab资源时，如果只是通过的话，这样只会release掉这个prefab所使用的json文件，而prefab所引用的spriteFrame以及其他的一些资源并不会释放掉，这样就有可能会造成内存的垃圾，长时间占用内存</li>
<li> 配合getDependsRecursively就可以正确的销毁掉prefab。</li>
</ul>
</li>
<li>3.3.3 如何找到“垃圾”<ul>
<li>随着游戏的运行，总会有一些内存是长时间不使用，同时又因为我们疏忽从而造成内存上的占用以及浪费。</li>
<li>通过google提供的snapshot以及Allocation Profile工具可以帮助我们找到这些垃圾</li>
<li>查找内存“垃圾”过程中需要注意的是：<ul>
<li>1.注意简单的对象创建，例如数组，{}</li>
<li>2.注意不要忽略匿名函数</li>
<li>3.注意匿名函数使用的外部变量将被匿名函数持有</li>
<li>4.利用Timeline 观察 GC 调用频率</li>
<li>5.寻找长期不释放的蓝色内存</li>
</ul>
</li>
</ul>
</li>
<li>3.3.4.复用一切可复用的对象<ul>
<li>最后是内存使用的一个理念：复用一切可复用的对象。</li>
<li>复用，并不仅仅是为了节省对象在alloc造成的开销，更重要的是避免GC时带来的额外开销。</li>
<li>像一些战斗中的掉血数字，敌人的血槽，怪物，子弹，英雄头像等等，都是我们常常回去做复用的地方。</li>
<li>但还有一些地方我们不能忽略，比如：</li>
<li>基础对象：cc.v2，cc.color 等。</li>
<li>数组和对象 {}。</li>
<li>对于基础的对象我们可以直接进行赋值从而达到复用的目的。</li>
<li>对于常见一些复杂对象，我们可以使用对象池NodePool进行复用。</li>
<li>参考引擎源码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto.add = <span class="function"><span class="keyword">function</span>(<span class="params">vector,put</span>)</span>&#123;</span><br><span class="line">  out = out || <span class="keyword">new</span> Vec2();</span><br><span class="line">  out.x = <span class="built_in">this</span>.x + vector.x;</span><br><span class="line">  out.y = <span class="built_in">this</span>.y + vector.y;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需要注意的是：注意闭包，注意复用时避免泄漏为全局变量</li>
</ul>
</li>
</ul>
<h3 id="4、CPU占用及性能优化"><a href="#4、CPU占用及性能优化" class="headerlink" title="4、CPU占用及性能优化"></a>4、CPU占用及性能优化</h3><ul>
<li><p>4.1 使用Performance定位问题</p>
<ul>
<li><p>针对CPU占用的情况，我们有很多的优化方案，但实际的项目开发过程中，更重要的是找到哪个地方是问题点。只要我们能够快速的找到问题点，那么解决方案也就应运而生了。</p>
</li>
<li><p>通过google开发者工具中的Preformance工具，可以截取一段时间内，程序运行的情况进行分析。如果在某一段时间内，CPU占用过高，导致帧率下降卡顿，那么我们可以在结果中像上图一样看到存在红色的热点帧。</p>
</li>
<li><p>通过针对这些热点帧的调用栈的分析，我们可以找到是哪一些接口的CPU占用情况比较严重。在找到热点函数后，我们就可以针对具体的函数做优化。</p>
</li>
<li><p>总之需要注意的是：</p>
<ul>
<li>1、观察整体性能</li>
<li>2、观察分析局部热点帧</li>
<li>3、通过调用栈分析热点</li>
</ul>
</li>
</ul>
</li>
<li><p>4.2 使用ESLint</p>
<ul>
<li>很多时候我们的CPU占用过高，经常是由于我们在编码过程中对于语法的不注意，或者是疏忽导致的。包括一些内存泄漏的问题，闭包的处理等等。</li>
</ul>
</li>
<li><p>4.3 控制游戏帧率</p>
<ul>
<li><p>4.3.1 分离逻辑帧以及渲染帧</p>
<ul>
<li>参考上面mainloop的代码，在默认的情况下面，我们的逻辑帧和渲染帧是相同的帧率，默认都是60帧。</li>
<li>但实际的项目开发过程中，像一些回合制的游戏，卡牌类游戏，或者是一些不需要太实时的游戏，实际上并不需要逻辑保持60帧的帧率在运行，从而造成性能的浪费，导致手机的电量消耗以及发热严重。</li>
<li>这时我们就可以将这一段代码进行改造，定制一下引擎，利用fixUpdate的方式，我们可以很轻松的将逻辑帧以及渲染帧进行分离。比如渲染帧保持60帧，而逻辑帧按照30帧的帧率运行。</li>
<li>这样逻辑帧和渲染帧就分离开来了，在运行时，逻辑帧的帧率我们可以统一设置，也可动态控制。</li>
<li>比如在需要创建大量对象时，我们就可以动态的提高逻辑帧的帧率，配合之前说过的async，从而加速对象的创建。</li>
<li>又比如在一些需要网络同步的游戏中，我们可以通过渲染帧帧率比逻辑帧高的特性，将一些因为网络问题导致的堆积数据取出来，采用一些插值算法，让渲染帧进行平滑的过渡渲染。这样就不会发生突然的瞬移同步。</li>
</ul>
</li>
<li><p>4.3.2 控制物理系统以及碰撞系统的帧率</p>
<ul>
<li>如果有使用到物理系统，也可以去控制物理系统的帧率。</li>
<li>默认物理系统的帧率与游戏帧率是一致的，但有些时候我们如果只是做粗略模拟的话可能并不需要这么高的帧率。这时我们可以通过一下的一些参数设置来控制物理系统的帧率：</li>
<li><a target="_blank" rel="noopener" href="https://docs.cocos.com/creator/manual/zh/physics/physics/physics-manager.html#%E8%AE%BE%E7%BD%AE%E7%89%A9%E7%90%86%E6%AD%A5%E9%95%BF">https://docs.cocos.com/creator/manual/zh/physics/physics/physics-manager.html#%E8%AE%BE%E7%BD%AE%E7%89%A9%E7%90%86%E6%AD%A5%E9%95%BF</a></li>
<li>var manager = cc.director.getPhysicsManager();</li>
<li> // 开启物理步长的设置</li>
<li>manager.enabledAccumulator = true;</li>
<li>// 物理步长，默认 FIXED_TIME_STEP 是 1/60 </li>
<li>manager.FIXED_TIME_STEP = 1/30;</li>
<li>// 每次更新物理系统处理速度的迭代次数，默认为 10</li>
<li>manager.VELOCITY_ITERATIONS = 8;</li>
<li>// 每次更新物理系统处理位置的迭代次数，默认为 10</li>
<li>manager.POSITION_ITERATIONS = 8;</li>
</ul>
</li>
<li><p>4.3.3 JS代码级优化</p>
<ul>
<li><p>很多时候我们对于CPU的优化都会从算法的方面着手，关于算法这一块优化方案多种多样，很多都需要根据项目的实际情况以及游戏的设计出发的。</p>
</li>
<li><p>我们经常会聚焦于算法级的优化上，而忽略掉代码级的优化。</p>
</li>
<li><p>这里带来的就是代码级的优化</p>
<ul>
<li>4.3.3.1 数组操作<ul>
<li>增加数组元素时，更推荐使用：array[array.length] = 0;</li>
<li>相比较push的方法，代码执行效率上我们可以看下对比：</li>
<li>push：3.4448ms </li>
<li>array[array.length]:2.9650ms</li>
<li>会有一定的提升，但提升的空间有限，因此不是强烈推荐，只是针对需要反复大量执行的代码时，更推荐使用。比如大量的a星寻路计算时，可以在编码时随手注意一下</li>
</ul>
</li>
<li>4.3.3.2 for循环<ul>
<li>for(let i = 0;i &lt; arr.length; i++)    add:17.24194</li>
<li>for (const key in arr)                add:213.42602</li>
<li>for (const key of arr)                add:25.30590</li>
<li>arr.forEach(element =&gt; {})            add:17.88500</li>
<li>强烈不推荐使用for-in的方式进行for循环，效率极其低下，同时随着游戏不断的运行，for-in还不能被jit优化。因此千万不要使用for-in</li>
</ul>
</li>
<li>4.3.3.3.arguments<ul>
<li>js中如果要实现类似C++中的多态，可以通过arguments去达到。</li>
<li>这样我们可以通过相同的接口，只是参数的不一致从而达到不同的逻辑运行效果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argumentsTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类似上面这样的使用。</li>
<li>这种方式虽然使用上看起来很秀，但要注意的是，性能也是极其低下的，需要这种情况，不要偷懒，多写几行代码，拆分成几个不同的函数进行调用会更好。</li>
<li>强烈推荐不要在工程中使用arguments</li>
</ul>
</li>
<li>4.3.3.4 try-catch or try-finally 以及 eval<ul>
<li>强烈建议不要使用任何的try-catch or try-finally 以及 eval，执行效率极其低下，很容易造成游戏的卡顿。</li>
<li>例如try-catch or try-finally系列，如果没有错误抛出，那就还好。一旦有错误抛出，效率直线下降。</li>
</ul>
</li>
</ul>
</li>
<li><p>4.3.3.5 global value</p>
<ul>
<li>在使用全局变量时，类似下面这样<br>```js<br>gIndex = 0;<br>for (let i = 0; i &lt; n; i++) {<br>gIndex += i;<br>}<br>// time:12.9731</li>
</ul>
<p> // 不要直接使用gIndex，使用局部变量进行一下转换，效率会快很多：<br> var localIndex = gIndex;<br> localIndex = 0;<br> for (let i = 0; i &lt; n; i++) {<br>   localIndex += i;<br> }<br> // time:2.99121<br> ```  </p>
<h3 id="写代码时值得注意的点："><a href="#写代码时值得注意的点：" class="headerlink" title="写代码时值得注意的点："></a>写代码时值得注意的点：</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.如何提升代码性能件? code Review</p>
<ul>
<li>(1)减少循环调用。—先判断再循环</li>
<li>(2)仅在改变时更新显示。</li>
<li>(3)增加代码更新的延时（分帧执行）。eg：在updat中，设置时间间隔调用函数</li>
<li>(4)在初始化时获取并缓存组。</li>
<li>(5)避免昂贵的api调用。—启动时缓存要使用的节点等</li>
<li>(6)update/lateUpdate/其他事件函数—<ul>
<li>隐藏开销:1.在引擎层和脚本层的每帧交互。</li>
<li>2.每帧调用前会进行的安全检查，a.检查（游戏对象是否还存在）gameObject有效性。b.多个对象开销叠加。</li>
<li>3.建议移除空的update。</li>
</ul>
</li>
<li>(7)向量运算：开平方开销很大</li>
</ul>
<p>性能优化原则：</p>
<ul>
<li>多使用内存、缓存或其他方法；</li>
<li>减少cpu计算量，减少网络加载耗时；</li>
<li>适用于所有编程的性能优化–空间换时间；</li>
</ul>
<p>让加载更快：</p>
<ol>
<li>减少资源体积，压缩代码；</li>
<li>减少访问次数，合并代码，SSR服务端渲染，缓存；</li>
<li>使用更快的网络：CDN；</li>
</ol>
<p>让渲染更快：</p>
<ol>
<li>CSS放在head，js放在body最下面；</li>
<li>尽早开始执行js，用Domcontentloaded触发；</li>
<li>懒加载（图片懒加载，上滑加载更多）；</li>
<li>对 Dom 查询进行缓存；</li>
<li>频繁 Dom 操作。合并到一起再插入Dom 结构中；</li>
<li>节流（throttle），防抖（debounce），体验优化</li>
</ol>
<ul>
<li><p>合并代码：比如：有3个文件都是3kb，就可以合并为一个9kb的文件，访问一次就可以；</p>
</li>
<li><p>缓存： </p>
<ul>
<li>静态资源加hash，根据文件内容计算hash；</li>
<li>文件内容不变，则hash不变，则 url 不变；</li>
<li>url 和 文件不变，则自动触发http缓存机制，返回304；<br>（第一次请求一定会返回，如 10 kb 的文件，只要 url 和 文件不变，下一次请求就直接返回 304 状态码，这个很小，很快，告诉前端用之前的缓存就可以）</li>
</ul>
</li>
<li><p>SSR： </p>
<ul>
<li>服务端渲染：将网页和数据一起加载，一起渲染；</li>
</ul>
</li>
<li><p>非SSR：</p>
<ul>
<li>前后端分离：先加载网页，再加载数据，再渲染数据；</li>
</ul>
</li>
</ul>
<p>小结：性能优化：1.编码规范。2.UI卡顿解决。3.场景模型优化。4.Shader优化。5.GC Alloc</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">cc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/posts/59257/">http://yoursite.com/posts/59257/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://github.com/wiyacho" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">永超の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cocos-creator/">cocos creator</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/056.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button" type="button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="wechat" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="alipay" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/61574/"><img class="prev-cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/034.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Cocos Creator系列之基础面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/45897/"><img class="next-cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/032.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TCP/IP协议</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/13200/" title="Cocos Creator系列之常用api"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/036.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-09</div><div class="relatedPosts_title">Cocos Creator系列之常用api</div></div></a></div><div class="relatedPosts_item"><a href="/posts/33576/" title="Cocos Creator系列之打包Android"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/035.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-08</div><div class="relatedPosts_title">Cocos Creator系列之打包Android</div></div></a></div><div class="relatedPosts_item"><a href="/posts/42726/" title="Cocos Creator系列之热更新"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/037.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-09</div><div class="relatedPosts_title">Cocos Creator系列之热更新</div></div></a></div><div class="relatedPosts_item"><a href="/posts/48078/" title="CocosCreatorToJava通信机制"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/056.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-07</div><div class="relatedPosts_title">CocosCreatorToJava通信机制</div></div></a></div><div class="relatedPosts_item"><a href="/posts/61574/" title="Cocos Creator系列之基础面试题"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/034.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-07</div><div class="relatedPosts_title">Cocos Creator系列之基础面试题</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> cc</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>